Epitech Security Lab
http://esl.epitech.eu




B2 securite
Alteration du flux d'execution d'un binaire - Part 1



Le fichier INFO contient beaucoup de choses interessantes
mais pas forcement utiles dans le cas present.
A vous de trier, d'y repasser.

Lisez bien ce qui suit juste avant "Dump process".

Ce qui est a partir de "Dump process", puis
memory patching, est a lire en diagonale, tout comme
INFO, il vous sert pour l'exo1337 puis pour
le grand final, le patch d'un binaire en memoire.
Si vous bloquez, lisez bien tout.



Le but de ce TP est au minimum de finir check_access et
ex1 a ex4. Ce que vous devez comprendre, c'est la
difference entre un binaire sur le disque dur et un binaire
en memoire. On peut vous empecher de lire un fichier sur
le disque avec un chmod 111, mais la memoire ou il sera
execute vous appartient. Vous pouvez donc aller la lire
et la modifier.

Vous jouerez pour ca avec le linker rtld, et avec sa variable
LD_PRELOAD. Il existe bien evidemment des tonnes d'autres facons,
mais celle ci est la plus simple pour vous (ptrace(2) en est
une autre par exemple).



* Architecture rapide de la jail

~/tpN/README
Contient les infos pour commencer

~/INFO
Plein d'infos plus ou moins utiles dans le cas present

~/tpN/bin
contient les binaires en --x--x--x a exploiter

~/tpN/src
contient les sources de ces derniers

Vous pouvez coder n'importe ou dans votre ~,
faut juste que vous n'ecrasiez pas les binaires a exploiter.
C'est pas la peine de recompiler les sources, elles
sont la A TITRE D'INFORMATION (pour trouver les bonnes
fonctions a surcharger).



* LD_PRELOAD

LD_PRELOAD est une variable d'environnement qu'utilise ld.so(8) afin de
remplacer les librairies^Wbibliotheques standards par les votres.
Ce procede fonctionne uniquement si le binaire utilise les libs en
dynamique, on peut savoir ca en utilisant la commande ldd(1).

Le but ici est de montrer qu'on peut remplacer les fonctions importees
par les notres, pour ce faire prenez et etudiez le binaire check_access,
il utilise la fonction getuid(2) pour verifier que l'utilisateur est
root, faites vous passer pour lui.

NOTE: Pour compiler votre module, n'oubliez pas un -shared (cf man gcc).

Une fois compilee, preloadez la avec un setenv LD_PRELOAD `pwd`/votrelib.so
Et executez le binaire qui est en --x--x--x (check_access).

Vous recuperez une passphrase, allez la valider sur
# ~/scoring1 <PASSPHRASE> <VOTRE_PSEUDO>

Vous pourrez ensuite faire un cat (n'oubliez pas le -e !) sur ranking.txt
histoire de voir l'avancement des autres.

Passez a l'ex1 puis 2 puis 3 puis 4.

Toujours en utilisant du LD_PRELOAD, ou du LD_LIBRARY_PATH.

Si vous reussissez le tout sans encombres, que vous vous sentez
plus pisser, que vous etes le roi du LD_PRELOAD, on peut commencer
a travailler sur le dump de processus (en aucun cas obligatoire,
complique pour votre niveau, et surtout uniquement pour des gens
motives a descendre un peu plus bas).








* Dump du process

Si vous avez reussi, vous avez trouve le "secret".
Et la vous vous dites que vous auriez pu le faire avec un
"strings check_access", comme le secret n'est qu'une simple string en dur,
mais non, l'executable est en "exec" only (impossible de le "read").

"Ce n'est pas un probleme."
Vous n'avez pas les droits pour lire le fichier sur le disque, mais vous
pouvez le faire en memoire.

Tout d'abord, on vous ment ! Vos programmes ne debutent pas par
la fonction main, le vrai nom du point de depart de vos programmes
est "_start" (pour faire simple), dans cette fonction divers initialisations
sont effectuees. Ce qui nous interesse ici, ce sont les "constructors".

Pour reussir a dumper (i.e.: action de copier de la memoire sur le disque)
le processus en memoire, nous allons ajouter un constructor dans le programme
check_access.

ld.so(8) va automatiquement ajouter les constructors des differents modules
a l'initialisation, vous devez donc injecter votre module a l'aide d'un
LD_PRELOAD.

NOTE: Pour savoir ou sont mappees les binaires, faites :
gandalf% objdump -p ./a.out | grep LOAD\ off
    LOAD off    0x00000000 vaddr 0x08048000 paddr 0x08048000 align 2**12
				 ^^^^^^^^^^
NOTE: Pour definir une fonction comme etant un constructor, il faut mettre
un "__attribute__ ((constructor))" devant la fonction.

Maintenant vous devez ecrire un constructor qui va ecrire dans un fichier
le binaire en memoire.

Attention, le binaire obtenu n'est pas utilisable en tant qu'executable !
En effet, le binaire etant charge en memoire, divers structures internes
ont ete modifie.
Il est cependant possible de dumper un binaire fonctionnel, mais ceci
depasse le cadre de ce tp. :)

Vous pouvez maintenant utiliser strings sur ce binaire.




* Patch

Il reste des gens ?

Vous devez prendre en compte qu'on peut modifier un binaire
apres sa compilation et sans les sources.
En effet, un executable n'est qu'un fichier contenant divers structures
le definissant et des sections contenant, en autre, du code et des donnees.
Interessons nous au code, ce sont des instructions assembleur x86.

NOTE: Le but de ce tp n'est pas de vous apprendre l'asm (vous aurez votre
tech2 pour ca), mais de fournir des bases pour comprendre comment ca marche,
grosso-modo.


On reprend l'exemple de check_access, voici la fonction qui verifie l'uid:

Adresse	       Code hexa des instr     Instructions assembleur

8048494:       55                      push   %ebp
8048495:       89 e5                   mov    %esp,%ebp
8048497:       83 ec 08                sub    $0x8,%esp
804849a:       e8 01 ff ff ff          call   80483a0 <getuid@plt>
804849f:       3d 96 11 01 00          cmp    $0x11196,%eax
80484a4:       75 09                   jne    80484af <fwrite@plt+0xff>
80484a6:       c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%ebp)
80484ad:       eb 07                   jmp    80484b6 <fwrite@plt+0x106>
80484af:       c7 45 fc 01 00 00 00    movl   $0x1,-0x4(%ebp)
80484b6:       8b 45 fc                mov    -0x4(%ebp),%eax
80484b9:       c9                      leave  
80484ba:       c3                      ret  


Comme vous pourrez le voir plus loin avec le corewar, on peut interpreter des
valeurs numeriques en instructions, par exemple 0x55 signifie push %ebp en x86.

804849a:       e8 01 ff ff ff          call   80483a0 <getuid@plt>
Cette ligne appelle la fonction getuid, on trouvera l'uid dans %eax.
En pseudo C : "%eax = getuid()"

804849f:       3d 96 11 01 00          cmp    $0x11196,%eax
"cmp" ou CoMPare, permet de ... comparer, la valeur 0x11196 correspond a l'uid
de guasco_v avec celle contenu dans %eax.

80484a4:       75 09                   jne    80484af <fwrite@plt+0xff>
Enfin, "jne" ou Jump Not Egal, saute a une adresse pour afficher le message d'erreur
si les deux valeurs ne sont pas egales.

La, on se dit que ca pourrait etre sympa de supprimer le jne (quoi qu'on puisse
faire autrement).
En x86, une instruction permet de ne rien faire, c'est le nop (No OPeration)
sa valeur en hexadecimal est 0x90.

En utilisant le constructor de l'exercice precedent, vous allez ecrire une
fonction qui patch le programme pour que n'importe qui puisse etre authentifie.
Si, par hasard, vous vous mangez des SIGSEGV : mprotect(2) et regarde la taille
des instructions.

Si vous etes arrive la, on a sous-estime la promotion tech1.
