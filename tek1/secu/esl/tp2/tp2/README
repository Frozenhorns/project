tEpitech Security Lab
http://esl.epitech.eu




B2 securite
Introduction a la cryptographie




NOTE: Toutes personnes employant le terme "crypter" sont invitees a partir.
(On parle de chiffrement, chiffrer ou alors 'to encrypt'. Pareil, on ne
dit pas 'hacker' meme si c'est rentre dans le langage courant. To hack.)



Ce TP est par etapes, terminez bien l'etape 1 pour faire la 2,
puis la 3 etc.

Deux grandes parties, tout d'abord du code, avec la decouverte d'un
type de chiffrement symetrique simple : xor, puis un peu de theorie
afin de ne pas se sentir perdu.
Ensuite vous appliquerez la theorie grace a OpenSSL.


Le but de ce TP est de reussir jusqu'au 4/,
et de comprendre le concept de symetrique/asymetrique explique
par la suite.


Cela se termine par une utilisation d'OpenSSL sur un fichier.
Les interesses se renseigneront sur les possibilites d'OpenSSL,
qui est capable de generer des tunnels reseaux, de faire le
cafe et de generer de la biere a travers un echange SSLv3/TLS.


Tout comme le TP1, vous utiliserez ~/scoring2 pour valider,
et ~/ranking2.txt pour regarder l'avancement de la salle.
Seuls les premiers exos sont scorables, le reste etant plus
theorique.
Le 6 est egalement scorable, et le ex1337, la pour vous apprendre a prendre
du recul par rapport a ce que vous avez appris.

Pour copier en local le contenu du repertoire (si vous voulez le
garder), utilisez scp depuis votre compte unix de cette maniere :

scp -i ./clef.dsa -r -P <port> login@adresse_des_jails:./ ./tp2




///
1/ Le code bidon
/

Faites un programme qui affiche "Je te casse la gorge\n".
Il sera a rendre dans le dossier ~/tp2/bin et s'appellera ex_1
Compile evidemment.

Appelez ensuite ~/scoring2 avec l'argument '1'

(tp2_g42@tech1 1 ~) cc my_src.c -o ~/tp2/bin/ex_1
(tp2_g42@tech1 2 ~) chmod 755 ~/tp2/bin/ex_1
(tp2_g42@tech1 3 ~) ~/tp2/bin/ex_1 | cat -e
I am a rainbow hat!!$
(tp2_g42@tech1 4 ~)~/scoring 1 mon_pseudo
...
(tp2_g42@tech1 5 ~)

Pas trop dur ca va ? :)



///
2/ Commencons a feinter
/

Imaginez que votre chaine 'Je te casse la gorge\n' soit
confidentielle. Vous ne voulez pas qu'on sache que votre
programme affiche cette chaine avant qu'on l'execute.
Un simple 'strings ~/tp2/bin/ex_1' permet de la recuperer.
Reprenez votre code, coupez la chaine en deux ou trois,
et reaffichez la.

Le but est d'obfusquer cette chaine afin qu'elle n'apparaisse
plus en entier si on regarde le binaire.
Utilisez printf ou puts, n'utilisez pas write (un bug de
bufferisation sur notre scoring) quoi que maintenant ca a l'air
de fonctionner.

Posez le binaire dans ~/tp2/bin/ex_2 et scorez-le.



///
3/ Vous avez dit "chiffrer" ?
/

*	Exemple simple du xor (ECB)
**	Coder un binaire qui chiffre avec un xor

La methode que vous utiliserez s'appelle ECB (Electronic CodeBook), elle est
reputee faible et est donc rarement utilisee.

Vous chiffrerez votre chaine grace a un xor octet a octet avec une clef
d'un seul octet.
la lettre 'A' ^ '\xdd' (lettre A xor clef 0xcc) donnera un caractere,
ce caractere ^ '\xdd' redonnera la lettre A.
Nous avons donc un moyen de chiffrer, puis dechiffrer.
N'utilisez pas '\0' comme caractere car ^ 0 equivaut a ne rien faire.

Vous coderez un premier programme qui transformera votre chaine en clair
en une autre chiffree (utilisez une sortie en hexa, la chaine chiffree
a de grandes chances d'etre non imprimable).

Le scoring2 verifie le binaire ~/tp2/bin/ex_3


Typiquement a la fin vous aurez un tableau de ce type :

static char g_secret[] =
{
   0x9e, 0xa9, 0xa2, 0xa8, 0xa9, 0xb6, 0xe1, 0xba, 0xa3, 0xb9, 0xbf, 0xec,
   0xad, 0xec, 0xb8, 0xa3, 
   0xb9, 0xbf, 0xec, 0xa0, 0xa9, 0xbf, 0xec, 0xa9, 0xa2, 0xaa, 0xad, 0xa2,
   0xb8, 0xbf, 0xe0, 0xec, 
   0xaf, 0xa9, 0xec, 0xbf, 0xa3, 0xa5, 0xbe, 0xe0, 0xec, 0xad, 0xec, 0xa0,
   0xad, 0xec, 0xaf, 0xa3, 
   0xb9, 0xbe, 0xbf, 0xec, 0xbc, 0xad, 0xbf, 0xb8, 0xa9, 0xb9, 0xbe, 0xe2,
   0xec, 0xe1, 0xe1, 0xec, 
   0x9c, 0xa9, 0xa8, 0xa3, 0xae, 0xa9, 0xad, 0xbe, 0xcc
};


qui contiendra votre "Je te casse la gorge\n" xor octet par octet
avec une clef a vous (peu importe sa valeur) (une clef de 1 octet).

puis

Une fonction qui le dechiffrera octet par octet avec votre clef.
et un printf du resultat.

et donc

Votre chaine aura disparu du binaire, mais il permet toujours d'afficher
"Je te casse la gorge\n".



Ce type de chiffrement est dit "symetrique".

Le chiffrement symetrique (aussi appele a cle secrete) chiffre et dechiffre
les donnees avec la meme cle, c'est pourquoi la cle doit demeurer protegee.
Dans notre cas c'est une tres mauvaise idee, puisque la clef se trouve
dans le binaire. Ca ne fait que ralentir la recherche.

Il n'y a pas de solution pour cacher une chaine dans un binaire qui
est lisible.

Une des solutions serait de se fier a une autorite superieure, typiquement
en utilisant un binaire "setuid". Un binaire "setuid" prend
les droits de l'utilisateur possesseur du binaire.
Le binaire 'scoring2' est setuidm michel.
$ ls -l ~/scoring2
Notez le 's' pour setuid.
Vous ne pouvez pas le LD_PRELOAD,
ne pouvez pas le tracer (avec gdb par exemple), et s'il est juste
en execution pour vous (ce qui est le cas), vous ne pouvez pas le lire.

Les problemes en cryptographie sont tres rarement lies au algos
meme, ils sont surtout lies a la maniere dont les utilisateurs les
implementent.

Passons maintenant a des choses plus interessantes.



///
4/ Difference chiffrement symetrique, asymetrique
/

**	Symetrique

Il existe deux grandes categories de chiffrement symetrique : il y a
par flux et par bloc.
Par methode par flux chiffre bit a bit et donc ne decoupe pas le message,
elle est utilisee, en autre, par les cartes bleues et les GSM, e.g.: RC4,
A5/1, ...

Alors que la methode par bloc decoupe le message par bloc d'une taille
definie, e.g.: DES, 3DES, AES, ...

Il existe plusieurs facons d'appliquer le chiffrement par bloc, on trouve
le ECB (Electronic CodeBook), le CBC (Cipher Block Chaining), ...


**	Asymetrique

Le chiffrement asymetrique (cle publique / privee) utilise deux cles,
une pour chiffrer et une pour dechiffrer, l'une est privee et
l'autre secrete.

e.g.: RSA, DSA, ...

Les algorithmes de chiffrement asymetrique sont bases sur des fonctions a sens
uniques, prenons l'exemple de la factorisation.
Calculez 59 * 3 (= 177), l'operation n'est pas tres dure, par contre
factoriser en deux nombres premiers 177 (=  59 * 3), c'est beaucoup
plus complique.

Bref c'est lie aux nombres premiers, et ca marche. Les matheux passeront
leur soiree sur wikipedia, les autres apprendront a l'utiliser.


**	Hash : md5 sha1, ..?

Les fonctions de hachage (hash = condensat en francais) sont des fonctions a
sens unique, i.e. elles permettent a partir d'une entree, de generer un
condensat (ou empreinte), idealement parlant, il ne faut pas qu'on puisse
retrouver l'entree a l'aide du condense.
Ces fonctions sont souvents utilisees pour identifier des donnees, comparer
des mots de passe, ou meme signer des donnees lorsque cette fonction est couplee
avec une fonction de chiffrement asymetrique.
Les fonctions de hachage les plus connues sont md5 et sha1.



///
5/ Introduction a openssl
/

Assez blabla, maintenant un peu de pratique.
Faites tous ces tests sur le PIE, ils ne servent qu'a
vous familiariser avec l'outil.

Vous allez chiffrer et dechiffrer des fichiers avec du aes-cbc (chiffrement
symetrique) et du rsa (chiffrement asymetrique).


** AES-CBC

AES (Advance Encryption Standard) est un algorithme de chiffrement symetrique,
on va l'utiliser avec la methode CBC (Cipher Block Chaining).
La commande pour chiffrer est la suivante


*** Chiffrer

openssl aes-256-cbc -a -e -salt -in votre_fichier_clair -out votre_fichier_chiffre

aes-256-cbc est l'algorithme de chiffrement utilise, ici du aes en mode cbc avec
une clee de 256bits.
Sachez qu'il en existe d'autre (openssl ciphers -v)

-a (out -base64) permet d'encoder le fichier de sorti sous forme de string
     en base64

-e (facultatif) dit qu'on va chiffrer (encrypt)

-salt complexifie l'attaque par dictionnaire sur les clefs

-in fichier entrant

-out fichier sortant


*** Dechiffrer

La commande est similaire a un detail pres
openssl aes-256-cbc -a -d -salt -in votre_fichier_chiffre \
         -out votre_fichier_dechiffre

-d permet de dechiffrer

Le reste est similaire.
La clef symetrique est le password demande lors du chiffrement.
Grace a ca, vous pouvez passer un fichier a un ami a travers le reseau
sans etre inquiete (pour peu que votre password reste secret).
Cela necessite evidemment de passer le mot de passe a la personne
a qui vous voulez passer le fichier. Grace au chiffrement asymetrique
vous n'avez meme plus besoin de ca.


** RSA

RSA (Rivest Shamir Adleman) est un algorithme de chiffrement asymetrique,
dans ce cas vous allez devoir passer une cle publique a votre camarade.

Commencez par generer une cle privee

openssl genrsa -out "$USER"_priv 2048

genrsa dit qu'on veut generer une cle privee

-out <fichier> est le fichier qui contiendra la cle privee, si rien n'est
specifie, ca ira sur la sortie standard

2048 est la taille de la cle, par defaut c'est 512

Maintenant on va generer des cles publiques pour vos petits amis.
Une clef publique decoule d'une clef privee. On peut generer
une publique depuis la privee, mais l'inverse est impossible
evidemment.

openssl rsa -in "$USER"_priv -pubout -out "$USER"_pub

Vous avez en votre possession deux cles, une privee (votre_login_priv)
et une publique (votre_login_pub).
Votre ami fait de meme.


Chiffrons ! Commencez par recuperer la cle publique de votre amant,
et donnez lui la votre.

openssl rsautl -in fichier_clair -out fichier_chiffre -encrypt \
     -pubin -inkey cle_de_votre_ami

rsautl RSA UTiLity, permet de chiffrer/dechiffrer/signer des fichiers

-in fichier entrant

-out fichier sortant

-encrypt pour chiffrer

-pubin la cle est publique

-inkey la cle a utiliser

Vous avez genere un fichier chiffre, 'fichier_chiffre', avec sa clef
publique. La seule facon de le dechiffrer est d'utiliser la clef
privee associee a la clef publique. Cette clef n'est possedee que
par votre ami evidemment.
Envoyez lui le fichier par mail par exemple.
Il fera de meme de son cote.

Vous venez de recuperer un fichier qui a ete chiffre grace a la clef
publique que vous avez diffuse.
Dechiffrons !

openssl rsautl -in fichier_chiffre -out fichier_clair -decrypt -inkey votre_cle_privee

-in le fichier chiffre

-out le fichier dechiffre

-decrypt pour dechiffrer le fichier

-inkey votre cle prive

Vous avez reussi a faire un echange sur le reseau.
La chose a savoir c'est que tout d'abord, le chiffrement asymetrique est tres
gourmand en ressources (compare au symetrique). De plus, pour chiffrer
de gros fichier, il est necessaire d'avoir une grosse clef.

C'est pour cette raison que lorsque vous utilisez le chiffrement asymetrique,
que ce soit de cette maniere ou au travers de protocoles reseaux (notons
https, ssh, etc) la methode classique consiste a echanger une clef
*symetrique* (generee aleatoirement sur le moment) au travers d'un seul echange
*asymetrique*.

1/ generation d'une clef aleatoire
2/ echange asymetrique d'un fichier contenant le fichier
3/ utilisation du fichier pour un echange symetrique



Pour donner un exemple d'utilisation, le fingerprint qui apparait
lors de la premiere connexion sur un serveur openSSH n'est rien
d'autre qu'une empreinte de la clef publique du serveur.
Si vous l'accepter (en repondant 'yes'), la clef publique s'enregistre
dans votre fichier ~/.ssh/known_host, et permet lorsque vous vous
y reconnectez plus tard de s'assurer que c'est bien au meme serveur
que vous avez affaire (car pour generer cette empreinte, il faut
posseder la clef privee associee, et seul le vrai serveur peut
donc la generer).

Un autre exemple avec OpenSSH. La clef .dsa que vous
utilisez pour vous connecter est une clef privee DSA (asymetrique).
Le serveur ou vous etes contient juste la clef publique associee.
Elle est situee ici : ~/.ssh/authorized_keys
Lorsque vous demandez au serveur de vous connecter, vous annoncez
que vous avez la clef privee associee a la clef publique qu'il
possede. Pour le verifier, en gros il chiffre un truc aleatoire
avec la clef dans authorized_keys, vous l'envoie. Vous pouvez
le dechiffrer (comme vous avez la clef privee), vous lui renvoyez
le contenu et il vous laisse passer.

man ssh-keygen pour ceux qui veulent jouer avec les auths par clefs
pour openssh.



///
6/ Dechiffrons un rendu Security Quest
/

Vous dechiffrerez un rendu du security quest.
Un rendu Security Quest est compose de :

-> un tar contenant deux fichiers
 |
 -> ___key.txt.crypt
 |   qui est une clef symetrique chiffree grace
 |         a une clef publique asymetrique.
 |
 -> ___temp
    qui est un tar.bz2 chiffre avec la clef symetrique
          precedente.

Vous etes le correcteur, on vous rend un rendu de ce type,
vous possedez bien evidemment la clef privee correspondant a la
clef publique utilisee par l'etudiant, a vous d'aller lire le
rendu.
la clef privee dont vous avez besoin est dans /sq/ex6.pem
le chiffrement symetrique est aes-128-cbc, pour utiliser un fichier
plutot qu'un password, utilisez -kfile <fichier>, enlevez le -a,
le -salt, bref lisez de la doc sur le net.
le fichier de rendu de l'etudiant est dans /sq/ex6.justif
Utilisez le binaire 'file' pour tester les magic (et savoir ce
que vous manipulez).



///
7/ T'es une brute ?
/

T'en as pas assez ?
Essaye de finir le binaire /home/exo1337
Il te faudra le dumper comme au TP precedent, mais en plus
cette fois ca risque d'etre tres complique puisque la
passphrase sera chiffree avec xor.
Tu devras donc le desassembler ou bien trouver un truc auquel
on a pas pense.
Exo extremement complique, necessitant des notions en
assembleur. Source non disponible evidemment.

Il est surtout la pour prouver que meme si dans la theorie
vous pouvez dire "Ouais ca se casse, dans le binaire y a la clef et
je peux lire le binaire!",
et bien dans la pratique ca bloque une grande partie des gens.

A vous d'en tirer une conclusion personnelle.

